#+LATEX_CLASS: article

#+TITLE: Philosophy of Code
#+AUTHOR: Michael Mattie

* Rapid Delivery of Effective Software

Rapid development of effective software requires the knowledge and
experience to design, implement, and improve software technology.

Along the way many projects ditch tooling and process for speed,
thinking that this is the quickest way from: A -> B. The result is a
mock-up at best that has to be rewritten on the Investor or Customer
dime.

At Gauge Security we believe in delivery of quality implementation,
innovation, automation, and deadlines. With our processes, ideas, and
tooling our investors spend money on ROI, not rewrites of code built
like a wood shack in a winter of funds.

* Design, Process, and Tooling

Our Design Process is derived from extensive experience working
for fortune 10/100 Corporations:

- Cobalt/ADP (Enterprise Scale Datbase Ingest)
- Disney (Rapid Python Development]
- Comcast (System Integration/Micro-Service Platform Architecture)
- Oracle (Cloud BackPlane/Security/AAA)
- Amazon 1 (Mission Critical Network mapping)
- Amazon 2 (AWS Security for Capital One)

Along with my Experience I have a priceless skillset:

- I can turn books into capabilities

Being able to both learn and apply has allowed me to develop skillsets
far beyond what is usually encountered in school or work experience.

My section *"My Readings"* covers a range of my influences.

* System Design

#+BEGIN_CENTER
*/Vision - “building the impossible”/*
#+END_CENTER

System Design is a crucial aspect of building effective and flexible
systems that can be modified and enhanced without rewrites of
monolithic codebases.

My major influence is the UNIX command line. Utilizing a standard
format for data interchange, and highly configurable and focuses
components it is possible to achieve astounding power over data and
the system.

Many poor designs revolve around slapping together a database with a
monolithic app driving the process. Despite this falling out of favor
with a large number of services driven by application integration
tools like:

- AWS SQS
- AWS SNS

Many systems discard this component architecture for speed, or find a
lack of integration tools with on-site development.

Let's see how we can stand on the shoulders of giants and get
it right from the get-go.

* System Design - Modern Architecture 

#+BEGIN_CENTER
*/Imagine & Conceive/*
#+END_CENTER

Vision is a declaration of goals and refinement of the business
language nouns and verbs that delineates and articulates the scope,
functions, and parameters of the solution.

Rational Unified Process is the high level view of the development
process. This is a fully iterative approach, which can work if the
entities (which are deepest rooted dependencies) are encapsulated
inside services that pass well defined and simple messages.

** RUP (Rational Unified Process)

A process framework defining a staged delivery to expose issues as early as possible.

- Inception - make a initial evaluation to determine the cost and
  value of the project, decide to proceed to elaboration. It should
  produce minimal viability through essential use cases.

-	Elaboration - perform domain modeling and architecting. Produce a
  integration test suite to shake out the Representation Model and the
  architecture. This is a iterative process.
-	Construction - complete the implementation of the Use Cases.
-	Transition - Final release work not in the scope of continuous delivery.

System Language is where concepts are identified, if there is a
troublesome area use language to pinpoint, dissect, and and illuminate
the concepts or stumbling blocks of a design.

System Domain is the practice of distilling a vision description down
into the essential components and features of a successful system that
will leave a legacy of: eleganance, aesthetic, pragmatically useful
and maintainable system.

** Design

#+BEGIN_CENTER
*/“Interrelation between use and model”/*
#+END_CENTER

Perfect minimalism, wise selection of mechanism and the
interconnection. Simplicity of design gives emergent behavioral
complexity from first principles.

Underlying the rich landscape of the problem is the solution’s
essential truth in the USE/Model. Design is the tight feedback loop
between the learning and revising the USE/Model and validating it by
writing integration tests.

The tests exercise the API’s and mockups of internal logic verify that
the needs of the internal logic are met by the API’s.


** USE CASE/DOMAIN Splitting

USE cases are designed as sequence diagrams showing the interaction
between the user and the system. Each USE case interaction with the
system has a correlation identifier that identifies the case as it
propagates through the system. Service Domains can signal other
Service Domains in a intra-domain vocabulary.

*** Roles

Roles are built as state machines. Each state consists of a set of
messages that can be sent from that mode. Each response from the
system or choice by the performed by the user, or change in state is a
potential transition to another mode.

Each mode is represented by a ticket, with the messages as sub-tasks.

*** Messages

Messages are transitive immutable entities, passed between componets.
They are indicated by italic UML objects in the domain file, and in
the system file they are simply named.

*** Entities

Entities are persistent state with a cohesive, complete, and minimal
set of attributes. They are refined by normalization where the
identity of the Entity acts as the “key” to apply normalization.

In the domain file It is represented in UML as a bolded type, and can
have a integrity label below in angle brackets. Integrity labels
indicate the set of entities required to create, update, and
delete cohesively.

*** Service Domain Factoring

System components with related “knows about” topic relationships are
gathered into Service Domains that consume and produce messages in
that topic.

Each domain becomes a column in the sequence diagram. Each Service
Domain has its own description file.

** System Vocabulary & Catalog

#+BEGIN_CENTER
*/“Systemic seperation of concerns”/*
#+END_CENTER

System layers shared across domains and the Data Fabric consisting of
the combined vocabularies of the domains are combined into a single
view.

This view is a cohesive map of MESSAGES, ENTITIES, and API
are represented as a UML package with the name of the Service in
bold.

Roles are described as one or more messages, entities, and API's
involved in operations drawn in ovals.

** Implementation

#+BEGIN_CENTER
*/“The Right Way is the shortest path to success”/*
#+END_CENTER

*** Layers

- Not the domain layer
- Responsible for coordinating the domain as tasks, system interfaces,
  service integrations, user interface, and parallelism if any. This
  layer is kept as thin as possible.

- Domain representation
 - Representation of business concepts and rules through entities,
   components, roles, and messages. Largely concerned with persistent
   state, function, and decomposition.
 - Extremely loose coupling with the Application Layer and the Core layer.

- Technical Core
 - Implementation of processes and technical capabilities
 - The technical details of system support, service integrations, storage.
 - Purely technical factors such as performance, scaling, security,
   authentication, and configuration

** Principles
#+BEGIN_CENTER
*/“Principles are wisdom that end in a  Pyrrhic victory when discarded”/*
#+END_CENTER

*** Twelve Factor App

-	One Code Base in Version Control (This can be decomposed into
  multiple repostories with advanced tooling composition
  capabilities) independent of environments configurations, and
  dependencies.

-	Explicit Dependencies and Dependency Isolation

- Common code between repositories are packages, all dependencies are
  declared down to the operating system later via locking or static
  linking

- Config Values in Environment Variables. Config values are propagated
  from the environment bound launcher into environment variables
  consumed by the application processes.

- Backing Services: All resources are abstracted as config bound
  resources, local and remote.

- Build, Release, Run Build is combined with config -> release , and
  finally produce a Run.

- Stateless Processes All processes contain no locally attached state,
  all state is written to resources with ACID properties

- Port Binding - no web server or reverse proxy The app binds to a
  port bare, no web-server or reverse proxy is needed to run it.

- Scale via Processes. Scale horizontally with processes.

- Disposable Processes Make processes start and stop fast, make them
  disposable putting state in ACID resources

- Dev/Prod Parity: Keep Dev and Prod in sync so that changes can be rapidly promoted to Prod with confidence.

- Logs - Log to stdout: Log to stdout, use logging services to pick up
  the stream and make it analyzable.
- Admin via one-oﬀ programs and REPL’s Use one-oﬀ shell scripts and
  REPL’s to do admin tasks, glue together dashboards out of ssh calls
  and log parsing

*** Tests as Contracts

- Integration Tests as contracts - tests should reflect actual useful
  scenarios and not simply exercise coverage but miss the point. Test
  the expected behavior of the interfaces on one level and the
  implementation on another.

  Refactoring the implementation can change the implementation tests;
  but the interface tests should remain unchanged. 

  To make it organized, and even possible to auto-generate docs from
  the Unit Test code, make a Test suite for each interface scenario
  being tested.

  Documentation should briefly describe what the behavior of the
  mode, and the circumstances and types of the errors.

*** Outsourcing

Outsource anything outside of the Core Domain to libraries and
services vastly accelerating development and the creation of value.
If the problem is in another domain it probably should be outsourced,
especially if it is in another technical domain.

Beware of dependency hell by choosing libraries and services with
extremely mature API’s with minimal sub-dependencies. 

*** submodules vs. packages

Pull the sources for outsourcing into the repositories as sub-modules
and build packages into your own package repository so that the source
for the entire system is preserved.

*** Side-Effect Free

Side Effect Free Functions: as many functions as possible should
return a result, and have no other effect upon subsequent calls,
or alter the outcomes of other function.

This simplifies analysis, understanding, and eliminates vast numbers
of diﬃcult to solve.

*** Assertions

Assertions are Invariants that are like probes into the heart of the
design and the code. Well stated is single invariants or as Hoare
predicate transformers stating the pre and post conditions of the
function.

*** Simplify Associations

Simplify Associations: Reduce connections and cardinality complexity
of relationships with constraints and layers found in deeper
understanding of the problem domain.

Use Stored Procedures or Object Relational Mappers to abstract
Entities and Aggregates from the storage structure. This also
abstracts storage quirks from the Technical Core layer.

Stored Procedures enforce locking and return denormalized rows 
for compound objects.

*** Factories are functions or boxes with

underlined names that create, update, retrieve entities, or create
complex or polymorphic objects. If the factory is for a object with
persistent storage zero args should create, one argument should write
the object, and keyword args should query for a existing object.


** Summary

The Design principles can actually be developed quickly with things
like MarkDown and other shorthand systems that can generate docs
quickly.

The only thing that requires manual fiddling is diagrams which should
be sparse considering how much labor they require. One rapid tool for
creating diagrams is mind mapping which is a very good approach for
quickly diagramming.

Don't ever think that these steps are formality with some value at
best, they are the thinking part of design, and the rules of the road
for implementation. Without them the result is often a coding spree
run amok, not a deliverable.

* My Readings

Here is list of my most influential sources, with a short description
of what they are, or the influence they had on me.

** The 12 Factor App

The 12 Factor app [[cite:&factor]] is a seminal document on Architecture
and implementation of horizontal scaling Micro-Service Systems.  It's
lessons are from the blood, sweat, and tears of years - if not
decades - of writing scalable and maintainable systems.

** Semantic Versioning

Semantic Versioning [[cite:&semver]] is the state-of-the art in release
practices for version formatting and the semantics of the version
scheme.

It's commentary on release practices is priceless.

** Git Flow

Git is powerful, but does not impose a Workflow. This has lead to a
lot of chaos, but has also allowed for a lot of research into the best
Workflows for version control.

Git-Flow [[cite:&flow]] Is the best of the Workflows and is tooled as
"git-flow" on most systems.  The combination of a well thought out,
experience driven, tooled Workflow is a huge asset to any project.

** Conventional commits

Most commit messages arise from a anarchy of practices leading
to git logs that are difficult to understand and impossible
to automate with tools.

Convential Commits [[cite:&conventional]] provide a standard for different
types of commits and what the types mean.  With git flow you can
understand the logs easily and also you can use tools to process the
logs.

** Introduction to Algorithms

MIT Introduction to Algorithms [[cite:&introduction]] is the definitive
work on the most common algorithms. It is the ten-ton-hammer of
algorithms with precise detail and thorough presentation of every
algorithm. This belongs on every programmer's shelf.

** Applied Cryptography

Applied Cryptography [[cite:&schneier2017applied]] is the seminal text on
cryptography theory, algorithms, and application.

The principles are explained in a precise and lucid manner. Not a
daily-driver for most programmers, but as a reference on cryptography
it has no peers.

** Design Patters

Design Patterns [[cite:&gamma1994design]] Definitely one of the most
influental books on programming ever written, introducing abstract
definitions of powerful code mechanisms in a language agnostic
description. This should be read cover-to-cover many times.

** Domain-driven Design

Domain-driven Design [[cite:&evans2004domain]] is a foundation
of design principles for system design and process. It
is a cover-to-cover read.

** Logic in Computer Science

Logic in Computer Science [[cite:&huth2004logic]]  deals with the modeling
and reasoning about computer code and systems. This is
a powerful book but very dense with predicate logic.

** Structure and Interpretation of Computer Programs

The original MIT intro to CompSci book [[cite:&abelson1996structure]] Is
my bible. Its thorough presentation of programming fundamentals in
scheme makes it a pleasant read, a tour-de-force of fundamentals, and
a fascinating treament of both functional and procedural programming.

** The Art of Computer Programming

Quite possibly the most famous series in programming. Written by Donald Knuth,
typeset in Tex - a system created to typeset the book correctly, It is
possibly the most correct text on programming.

Knuth famously wrote checks to anyone who could find a mistake in the
books. The checks were rarely cashed, they were one of the most
prized awards in programming culture. The series is four volumes currently

- Vol 1: Fundamental Algorithms [[cite:&knuth1998art]]
- Vol 2: Seminumerical Algorithms [[cite:&knuth2014art]]
- Vol 3: Sorting and Searching [[cite:&knuth1998art]]
- Vol 4: Combinitorial Algorithms [[cite:&knuth2022art]]

** The Structure of Scientific Revolutions

This classic text [[cite:&kuhn2012structure]] by Kuhn seperates
revolutionary ideas from incremental progress. Defining Revolutionary
Changes as paradim shifts and new models derived from those paradigm
shifts he pinpoints the tidal shifts in scientific thinking.

** Unix Power Tools

One of the most influential of my books Unix Power Tools
[[cite:&powers2003unix]] teaches the command line in a powerful way, with
examples of how to use the command line throught.

If you learn by example, and want to deep dive into the command line
this is the best book.

** Hackers, heros of the computer algorithms

Steven Levy [[cite:&levy2010hackers]] Hackers is a amazing presentation of
the early years of computer programming, personal computers, and video
game programming.

An easy read, and a good one.

** The Art of Unix Programming

The Art of Unix Programming [[cite:&raymond2003art]] is a very influential
book on designing systems the UNIX way and how to decompose complex
behavior into simple parts.

** The Cuckoo's Egg

The Cuckoo's egg [[cite:&stoll2000cuckoo]] was my first introduction into the world of
programming and UNIX. It inspired me to become a programmer.

** The Design and Evolution of C++

A lesser known work by Bjarne Stroustrup [[cite:&stroustrup1994design]],
in this book he discusses the context and the decisions that drove the
creation and evolution of C++. A must read for insight into the
creative and design process behind software.

** The Design of Every Day Things

The Design of Every Day Things [[cite:&norman2013design]] spawned
modern inteface design, and the rise of the product designer.
A must read for programmers to create intuitive software.

** The Soul of a new Machine

The Soul of a New Machine [[cite:&kidder1997soul]]

#+print_bibliography:


